# Week 5: Docker Basics & Advanced Challenge

## Challenge Tasks

### Task 1: Introduction and Conceptual Understanding

1. **Docker's Purpose in Modern DevOps**  

   The Docker platform enables developers to create, collaborate, test, monitor, ship, and run applications within lightweight containers, giving them the power to deliver better code more quickly. Docker simplifies and empowers development processes, also improving the reliability of applications across different environments.

2. **Containerization vs Virtualization**  

    **Virtualization**

    - Virtualization allows you to split a physical server into several virtual machines (VMs), each acting like a separate computer with its operating system, applications and allocated resources e.g. memory, processing power, storage, network.

    - Each virtual machine is isolated from the others.

    - This allows you to optimize resource utilization, improve scalability by easily adding, configuring, removing virtual machines as needed.

    - The hypervisor is a software component that manages multiple virtual machines in a computer. It ensures that each virtual machine gets the allocated resources and does not interfere with the operation of other virtual machines. There are two types of hypervisors.
    - A type 1 hypervisor, or bare-metal hypervisor, is a hypervisor program installed directly on the computer‚Äôs hardware instead of the operating system. Therefore, type 1 hypervisors have better performance, e.g., **Microsoft Hyper-V**

    - Also known as a hosted hypervisor, the type 2 hypervisor is installed on an operating system. Type 2 hypervisors are suitable for end-user computing, e.g., **Oracle VirtualBox**

    **Containerization**

    - Containerization involves bundling an application‚Äôs code with all the files and libraries it needs to run on any infrastructure. Containers abstracts the host operating system.

    - Each container shares the same operating system kernel but is isolated from other containers.

    - A host can support many containers concurrently.

    - Containers use a container engine or container runtime. This is software that acts as an intermediary agent between the containers and the operating system, providing and managing system resources that the application needs. Docker is the most popular open-source container engine.
---

### Task 2: Create a Dockerfile for a Sample Project

1. **Select or Create a Sample Application:**  
   - Choose a simple application (for example, a basic Node.js, Python, or Java app that prints ‚ÄúHello, Docker!‚Äù or serves a simple web page).

2. **Write a Dockerfile:**  
   - Create a `Dockerfile` that defines how to build an image for your application.
   - Include comments in your Dockerfile explaining each instruction.
   - Build your image using:
     ```bash
     docker build -t <your-username>/sample-app:latest .
     ```

3. **Verify Your Build:**  
   - Run your container locally to ensure it works as expected:
     ```bash
     docker run -d -p 8080:80 <your-username>/sample-app:latest
     ```
   - Verify the container is running with:
     ```bash
     docker ps
     ```
   - Check logs using:
     ```bash
     docker logs <container_id>
     ```

---

### Task 3: Explore Docker Terminologies and Components

1. **Key Terminologies:**  

   - Docker Image: A Docker Image that is a standardized package, contains a smaller version of Operating System and all binaries, config files, and other dependencies of our app. Images are built in layers. Each image is immutable, we can only add changes on top of it or create a new image.

   - Container: Simply put, containers are isolated processes for each of your app's components. Each component - the frontend React app, the Python API engine, and the database - runs in its own isolated environment, completely isolated from everything else on your machine.

    - Dockerfile: A Dockerfile is a text-based document that's used to create a container image. It provides instructions to the image builder on the commands to run, files to copy, startup command, and more.

   - Volume: Volumes are quite similar to Bind mount, but more efficient. But volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker.

   - Network: Container networking refers to the ability for containers to connect to and communicate with each other, or to non-Docker workloads.
    
    Containers have networking enabled by default, and they can make outgoing connections. A container has no information about what kind of network it's attached to, or whether their peers are also Docker workloads or not. A container only sees a network interface with an IP address, a gateway, a routing table, DNS services, and other networking details.
    
   - Docker Engine: Docker Engine is an open source containerization technology for building and containerizing our applications.

   - Docker Hub: An image registry is a centralized location to store Docker images. It can be either public or private. Docker Hub is a public registry that anyone can use. When we pull an image, Docker by default looks for it in the public registry and saves the image on our local system.

---

### Task 4: Optimize Your Docker Image with Multi-Stage Builds

1. **Implement a Multi-Stage Docker Build:**  
   - Modify your existing `Dockerfile` to include multi-stage builds.  
   - Aim to produce a lightweight, **distroless** (or minimal) final image.

2. **Compare Image Sizes:**  
   - Build your image before and after the multi-stage build modification and compare their sizes using:
     ```bash
     docker images
     ```
3. **Document the Differences:**  
   In a traditional build, all build instructions are executed in sequence, and in a single build container: downloading dependencies, compiling code, and packaging the application. All those layers end up in the final image. This approach leads to bulky images carrying unnecessary weight and increasing the security risks. 
   
   This is where multi-stage builds come in.

   - In the first stage, we choose a rich base image and install all our dependencies effortlessly.
   - In the second stage, we copy only the installed dependencies and execute those using a separate, very minimalistic base image.

   We can have multiple stages as per our requirement.

   As a result, we can segregate the build process from the runtime environment, resulting in a smaller image size that only includes the dependencies and libraries required to run our application.

---

### Task 5: Manage Your Image with Docker Hub
1. **Tag Your Image:**  
   - Tag your image appropriately:
     ```bash
     docker tag <your-username>/sample-app:latest <your-username>/sample-app:v1.0
     ```
2. **Push Your Image to Docker Hub:**  
   - Log in to Docker Hub if necessary:
     ```bash
     docker login
     ```
   - Push the image:
     ```bash
     docker push <your-username>/sample-app:v1.0
     ```
3. **(Optional) Pull the Image:**  
   - Verify by pulling your image:
     ```bash
     docker pull <your-username>/sample-app:v1.0
     ```

---

### Task 6: Persist Data with Docker Volumes
1. **Create a Docker Volume:**  
   - Create a Docker volume:
     ```bash
     docker volume create my_volume
     ```
2. **Run a Container with the Volume:**  
   - Run a container using the volume to persist data:
     ```bash
     docker run -d -v my_volume:/app/data <your-username>/sample-app:v1.0
     ```

---

### Task 7: Configure Docker Networking
1. **Create a Custom Docker Network:**  
   - Create a custom Docker network:
     ```bash
     docker network create my_network
     ```
2. **Run Containers on the Same Network:**  
   - Run two containers (e.g., your sample app and a simple database like MySQL) on the same network to demonstrate inter-container communication:
     ```bash
     docker run -d --name sample-app --network my_network <your-username>/sample-app:v1.0
     docker run -d --name my-db --network my_network -e MYSQL_ROOT_PASSWORD=root mysql:latest
     ```
3. **Document the Process:**  
   Containers have networking enabled by default, and they can make outgoing connections. A container has no information about what kind of network it's attached to, or whether their peers are also Docker workloads or not. A container only sees a network interface with an IP address, a gateway, a routing table, DNS services, and other networking details. That is, unless the container uses the `none` network driver.

---

### Task 8: Orchestrate with Docker Compose
1. **Create a docker-compose.yml File:**  
   - Write a `docker-compose.yml` file that defines at least two services (e.g., your sample app and a database).

   ```
   ---
   name: nginx-node-load-balancer  # name of the compose project
   services:
      web1:
         build: ./node-server
         hostname: web1
      web2:
         build: ./node-server
         hostname: web2
      nginx:
         build: ./nginx-config
         depends_on:
            - web1
            - web2
         ports:
            - "80:80"
   ```
   
2. **Deploy Your Application:**  
   - Bring up your application using:
     ```bash
     docker-compose up -d
     ```
   - Test the setup, then shut it down using:
     ```bash
     docker-compose down
     ```
3. **Document the Process:** 

   #### i. Project Name:

   ```yaml
   name: nginx-node-load-balancer
   ```
   - This sets the **name of the Docker Compose project** to `nginx-node-load-balancer`.
   - It's useful when managing multiple Compose projects on the same machine.


   #### ii. Services:   Docker Compose defines three services:  
   üîπ `web1` (Node.js App Server 1)  
   üîπ `web2` (Node.js App Server 2)  
   üîπ `nginx` (Reverse Proxy & Load Balancer)

   ---

   #### iii. `web1` and `web2` Services (Node.js Servers)
   ```yaml
   web1:
   build: ./node-server
   hostname: web1
   ```
   ```yaml
   web2:
   build: ./node-server
   hostname: web2
   ```
   - **`build: ./node-server`**  
   - Tells Docker to **build an image** using the `Dockerfile` inside the `node-server` directory.  
   - This directory contains a **Node.js application**.
   
   - **`hostname: web1` / `hostname: web2`**  
   - Assigns a hostname to each container.
   - These names help other containers refer to them in the **Docker network**.

   ‚úÖ **Purpose:** These two services act as **backend application servers** that handle requests.


   #### iv. `nginx` Service (Load Balancer)
   ```yaml
   nginx:
   build: ./nginx-config
   depends_on:
      - web1
      - web2
   ports:
      - "80:80"
   ```
   - **`build: ./nginx-config`**  
   - Builds an NGINX container using the configuration inside the `nginx-config` directory.  
   - This directory contains an `nginx.conf` file that sets up **load balancing** between `web1` and `web2`.

   - **`depends_on:`**  
   - Ensures that `nginx` starts **only after** `web1` and `web2` are up and running.  
   - However, it does **not** guarantee that the services are ready to accept connections (for that, health checks are needed).

   - **`ports:`**  
   - `80:80` ‚Üí Maps **port 80** of the **host machine** to **port 80** of the `nginx` container.  
   - This means that users can access the load balancer by visiting `http://localhost` in their browser.

   ‚úÖ **Purpose:**  
   - NGINX will act as a **reverse proxy** and distribute traffic between `web1` and `web2` based on its load-balancing strategy (e.g., round-robin, least connections, etc.).


### Task 9: Analyze Your Image with Docker Scout
1. **Run Docker Scout Analysis:**  
   - Execute Docker Scout on your image to generate a detailed report of vulnerabilities and insights:
     ```bash
     docker scout cves <your-username>/sample-app:v1.0
     ```
   - Alternatively, if available, run:
     ```bash
     docker scout quickview <your-username>/sample-app:v1.0
     ```
     to get a summarized view of the image‚Äôs security posture.
   - **Optional:** Save the output to a file for further analysis:
     ```bash
     docker scout cves <your-username>/sample-app:v1.0 > scout_report.txt
     ```
